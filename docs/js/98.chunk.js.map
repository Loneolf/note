{"version":3,"file":"js/98.chunk.js","mappings":"qIAAA,qhU","sources":["webpack://source-map/./src/mds/TS/装饰器.md"],"sourcesContent":["export default \"本篇讲述新版装饰器，也就是标准语法\\n> TS早期就支持装饰器，ESCMAScript标准通过的语法标准与早期TS支持的语法有较大差异\\n在TS 5.0版本同时支持两种装饰器语法，标准语法可以直接使用，传统语法需要打开--experimentalDecorators编译参数\\n\\n若`TS5.0`语法`vscode`提示不支持，更新`VScode`版本即可，`VScode`安装包内内置有`TS`，路径为·Microsoft VS Code\\\\resources\\\\app\\\\extensions\\\\node_modules\\\\typescript\\\\lib·，直接更改该目录下的TS文件为5.0版本的也可以\\n\\n#### 简介\\n装饰器的语法特征\\n（1）第一个字符（或者说前缀）是`@`，后面是一个表达式。\\n（2）`@`后面的表达式，必须是一个函数（或者执行后可以得到一个函数）。\\n（3）这个函数接受所修饰对象的一些相关值作为参数。\\n（4）这个函数要么不返回值，要么返回一个新对象取代所修饰的目标对象。\\n\\n装饰器是一种特殊类型的声明， 可以附加到类声明、方法、访问符、属性或参数上、在编译时执行只执行一次\\n装饰器可以为代码添加新功能而不影响代码的结构和逻辑，使代码可读性，可维护性和扩展性提高\\n```\\nunction simpleDecorator(value: any, context: any) {\\n    console.log(`hi, this is ${context.kind} ${context.name}`);\\n    return value;\\n}\\n\\n@simpleDecorator\\nclass A { } // \\\"hi, this is class A\\\"\\n```\\n如上装饰器simpleDecorator对类A进行装饰，无论A有没有实例，都会执行\\n\\n#### 装饰器的结构\\n装饰器函数的类型定义如下\\n```\\ntype Decorator = (\\n    value: DecoratedValue,\\n    context: {\\n        kind: string;\\n        name: string | symbol;\\n        addInitializer?(initializer: () => void): void;\\n        static?: boolean;\\n        private?: boolean;\\n        access: {\\n            get?(): unknown;\\n            set?(value: unknown): void;\\n        };\\n        metadata: DecoratorMetadata;\\n    }\\n) => void | ReplacementValue;\\n```\\n装饰器函数接收`value`(装饰对象)和`context`(上下文对象)两个参数，其中`TS`提供原生接口`ClassMethodDecoratorContext`描述上下文对象\\n```\\nfunction decorator(value: any, context: ClassMethodDecoratorContext) {\\n    // ...\\n}\\n```\\n- context对象属性，根据装饰对象不同而不同，其中只有kind和name必有，其余均是可选\\n- kind:字符串，表示修饰对象的类型，取值为  class | method | getter | setter | field | accessor\\n- name: 字符串或者Symbol值，装饰对象的名字，如类名、属性名等\\n- addInitializer(): 函数，添加类的初始化逻辑，无返回值\\n- private: boolean,所装饰的对象是否为类的私有成员\\n- static：布尔值，表示所装饰的对象是否为类的静态成员。\\n- access：一个对象，包含了某个值的 get 和 set 方法。\\n- metadata: 装饰器元数据，元数据: 用于描述数据的数据，5.2版本新增 [参考文字](https://www.doubao.com/chat/?guest_landing=1&login_source=chat_list_unlog&type=0)\\n\\n根据`kind`，标准装饰器可分为类装饰器、方法装饰器、属性装饰器、getter\\\\setter装饰器、accessor装饰器\\n\\n#### 类装饰器\\n```\\ntype ClassDecorator = (\\n    value: Function,\\n    context: {\\n        readonly kind: 'class';\\n        readonly name: string | undefined;\\n        addInitializer(initializer: () => void): void;\\n        readonly metadata: DecoratorMetadata;\\n    }\\n) => Function | void;\\n```\\n类装饰器接受两个参数，value为类本身，context是上下文对象，其中kind为固定值class，metadata是装饰器元数据，任意装饰器都存在\\n类装饰器用于对类进行操作，可以不返回值，也可以返回函数替代当前类的构造方法，还可以返回新的类替代原来的类\\n\\n通过装饰器对类添加方法\\n```\\nnterface IGreeter {\\n    greet: () => void\\n}\\ninterface User extends IGreeter { }\\n\\nfunction Greeter(value: any, context: any) {\\n    // value.prototype.greet = function () {\\n    //     console.log('你好');\\n    // };\\n    return class extends value {\\n        greet() {\\n            console.log('你好')\\n        }\\n    }\\n}\\n\\n@Greeter\\nclass User { }\\n\\nlet u = new User();\\nu.greet(); // \\\"你好\\\"\\n```\\n通过装饰器给类添加方法会有TS类型检测问题，可以使用接口技巧修复\\n\\n返会新的类替代原来装饰的类\\n```\\ninterface ICount {\\n    count: number\\n}\\ninterface MyClass extends ICount { }\\nfunction countInstances(value: any, context: any) {\\n    let instanceCount = 0;\\n    return class extends value {\\n        count: number\\n        constructor(...args: any[]) {\\n            super(...args);\\n            instanceCount++;\\n            this.count = instanceCount;\\n        }\\n    };\\n}\\n@countInstances\\nclass MyClass { }\\n\\nconst inst1 = new MyClass();\\ninst1 instanceof MyClass // true\\ninst1.count // 1\\n```\\n`context`中`addInitializer`方法用来定义类的初始化函数，在类完全定义结束后执行\\n```\\n// 为类注册指定名称的自定义HTML元素\\nfunction customElement(name: string) {\\n    return <Input extends new (...args: any) => any>(\\n        value: Input,\\n        context: ClassDecoratorContext\\n    ) => {\\n        context.addInitializer(function () {\\n            customElements.define(name, value);\\n        });\\n    };\\n}\\n@customElement(\\\"hello-world\\\")\\nclass MyComponent extends HTMLElement {\\n    constructor() {\\n        super();\\n    }\\n    connectedCallback() {\\n        this.innerHTML = `<h1>Hello World</h1>`;\\n    }\\n}\\n```\\n#### 方法装饰器\\n```\\ntype ClassMethodDecorator = (\\n    value: Function,\\n    context: {\\n        readonly kind: 'method';\\n        readonly name: string | symbol;\\n        readonly static: boolean;\\n        readonly private: boolean;\\n        readonly access: { get: () => unknown };\\n        addInitializer(initializer: () => void): void;\\n        readonly metadata: DecoratorMetadata;\\n    }\\n) => Function | void;\\n```\\n- kind：值固定为字符串method，表示当前为方法装饰器。\\n- name：所装饰的方法名，类型为字符串或 Symbol 值。\\n- static：布尔值，表示是否为静态方法。\\n- private：布尔值，表示是否为私有方法。\\n- access：对象，包含了方法的存取器，但是只有get()方法用来取值，没有set()方法进行赋值。\\n- addInitializer()：为方法增加初始化函数。\\n\\n方法装饰器会改写类的原始方法,如果方法装饰器返回一个新的函数，会替代所装饰的函数\\n```\\nunction replaceMethod(value: any, context: any) {\\n    return function () {\\n        // @ts-ignore\\n        return `How are you, ${(this).name}?`;\\n    }\\n}\\nclass Person {\\n    name: string\\n    constructor(name: string) {\\n        this.name = name;\\n    }\\n    @replaceMethod\\n    hello() {\\n        return `Hi ${this.name}!`;\\n    }\\n}\\nconst robin = new Person('Robin');\\nconsole.log(robin.hello()) // 'How are you, Robin?'\\n```\\n\\n利用方法装饰器，对类的方法进行延迟执行\\n```\\nfunction delay(milliseconds: number = 0) {\\n    return function (value: any, context: ClassMethodDecoratorContext) {\\n        if (context.kind === \\\"method\\\") {\\n            return function (...args: any[]) {\\n                setTimeout(() => {\\n                    // @ts-ignore\\n                    value.apply(this, args);\\n                }, milliseconds);\\n            };\\n        }\\n    };\\n}\\n\\nclass Logger {\\n    @delay(3000)\\n    log(msg: string) {\\n        console.log(`${msg}`);\\n    }\\n}\\n\\nlet logger = new Logger();\\n#### logger.log(\\\"Hello World\\\");\\n```\\n\\n#### 属性装饰器\\n```\\ntype ClassFieldDecorator = (\\n    value: undefined,\\n    context: {\\n        readonly kind: 'field';\\n        readonly name: string | symbol;\\n        readonly static: boolean;\\n        readonly private: boolean;\\n        readonly access: { get: () => unknown, set: (value: unknown) => void };\\n        addInitializer(initializer: () => void): void;\\n        readonly metadata: DecoratorMetadata;\\n    }\\n) => (initialValue: unknown) => unknown | void;\\n```\\n属性装饰器的第一个参数为undefined,不能从value获取所装饰属性的值\\n属性装饰器可以不返回值，但是返回值的话需要返回函数，该函数会自动执行，用于对装饰属性初始化，参数为装饰属性的初始值，返回值为最终值\\n```\\nfunction logged(value: undefined, context: ClassFieldDecoratorContext) {\\n    const { kind, name } = context;\\n    if (kind === 'field') {\\n        return function (initialValue: string) {\\n            console.log(`initializing ${String(name)} with value ${initialValue}`);\\n            return initialValue + '_';\\n        };\\n    }\\n}\\n\\nclass Color {\\n    @logged name = 'green';\\n}\\n\\nconst color = new Color(); // \\\"initializing name with value green\\\"\\ncolor.name // green_\\n```\\n#### getter、setter装饰器\\nassess略有不同，getter装饰器只有get，setter装饰器只有set\\n这两个装饰器要么不返回值，返回的话必须返回函数，取代原有的取值器或者存值器\\n```\\ntype ClassGetterDecorator = (\\n    value: Function,\\n    context: {\\n        readonly kind: 'getter';\\n        readonly name: string | symbol;\\n        readonly static: boolean;\\n        readonly private: boolean;\\n        readonly access: { get: () => unknown };\\n        addInitializer(initializer: () => void): void;\\n    }\\n) => Function | void;\\n\\ntype ClassSetterDecorator = (\\n    value: Function,\\n    context: {\\n        readonly kind: 'setter';\\n        readonly name: string | symbol;\\n        readonly static: boolean;\\n        readonly private: boolean;\\n        readonly access: { set: (value: unknown) => void };\\n        addInitializer(initializer: () => void): void;\\n    }\\n) => Function | void;\\n```\\n#### accessor 装饰器\\n\\naccessor修饰符是装饰器语法引入的新的属性修饰符，作用是为类属性自动生成取值器和存值器\\n使用时需要将tsconfig的target改为ES2015及以上版本才行\\n```\\nclass C {\\n    accessor x = 1;\\n}\\n// 等同于\\nclass C2 {\\n    #x = 1;\\n    get x() {\\n        return this.#x;\\n    }\\n    set x(val) {\\n        this.#x = val;\\n    }\\n}\\n```\\naccessor还可以与静态属性和私有属性一起使用\\n\\n类型定义\\n```\\ntype ClassAutoAccessorDecorator = (\\n    value: {\\n        get: () => unknown;\\n        set: (value: unknown) => void;\\n    },\\n    context: {\\n        readonly kind: \\\"accessor\\\";\\n        readonly name: string | symbol;\\n        readonly access: { get(): unknown, set(value: unknown): void };\\n        readonly static: boolean;\\n        readonly private: boolean;\\n        addInitializer(initializer: () => void): void;\\n    }\\n) => {\\n    get?: () => unknown;\\n    set?: (value: unknown) => void;\\n    init?: (initialValue: unknown) => unknown;\\n} | void;\\n```\\n装饰器参数value，是包含get()和set()的对象，可以不返回值，也可以反悔新的对象取代原有的set()、get()方法，还可以反悔init方法，用于改变私有属性的值\\n```\\n// 装饰器@logged3为x的存值器和取值器加上日志输出\\n\\nclass C3 {\\n    @logged3 accessor x = 1;\\n}\\nfunction logged3(value: any, { kind, name }: { kind: string, name: string }) {\\n    if (kind === \\\"accessor\\\") {\\n        let { get, set } = value;\\n        return {\\n            get() {\\n                console.log(`getting ${name}`);\\n                return get.call(this);\\n            },\\n            set(val: number) {\\n                console.log(`setting ${name} to ${val}`);\\n                return set.call(this, val);\\n            },\\n            init(initialValue: number) {\\n                console.log(`initializing ${name} with value ${initialValue}`);\\n                return initialValue;\\n            }\\n        };\\n    }\\n}\\nlet c3 = new C3();\\nc3.x; // getting x\\nc3.x = 123; // setting x to 123\\n```\\n#### 装饰器输出顺序\\n装饰器执行分两个阶段\\n（1）评估（evaluation）：计算@符号后面的表达式的值，得到的应该是函数。\\n（2）应用（application）：将评估装饰器后得到的函数，应用于所装饰对象。\\n应用装饰器的顺序依次为方法装饰器、属性装饰器、类装饰器\\n\\n```\\nfunction d(str: string) {\\n    console.log(`评估 @d(): ${str}`);\\n    return (\\n        value: any, context: any\\n    ) => console.log(`应用 @d(): ${str}`);\\n}\\nfunction log(str: string) {\\n    console.log(str);\\n    return str;\\n}\\n@d('类装饰器')\\nclass T {\\n    @d('静态属性装饰器')\\n    static staticField = log('静态属性值');\\n\\n    @d('原型方法')\\n    [log('计算方法名')]() { }\\n\\n    @d('实例属性')\\n    instanceField = log('实例属性值');\\n\\n    @d('静态方法装饰器')\\n    static fn() { }\\n}\\n\\n// 评估 @d(): 类装饰器\\n// 评估 @d(): 静态属性装饰器\\n// 评估 @d(): 原型方法\\n// 计算方法名\\n// 评估 @d(): 实例属性\\n// 评估 @d(): 静态方法装饰器\\n// 应用 @d(): 静态方法装饰器\\n// 应用 @d(): 原型方法\\n// 应用 @d(): 静态属性装饰器\\n// 应用 @d(): 实例属性\\n// 应用 @d(): 类装饰器\\n// 静态属性值\\n```\\n评估时，按照出现的顺序执行，一个方法火属性有多个装饰器，内层的装饰器先执行，然后是外层装饰器\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";"],"names":[],"sourceRoot":""}