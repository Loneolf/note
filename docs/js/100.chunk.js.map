{"version":3,"file":"js/100.chunk.js","mappings":"sIAAA,4uO","sources":["webpack://source-map/./src/mds/TS/类型运算符&类型映射&注释指令.md"],"sourcesContent":["export default \"### TS 类型运算符\\n我们可以使用TS提供的各种类型运算符，对已有的类型进行计算，得到新类型\\n\\n#### keyof\\n`keyof`单目运算符，用于提取对象的属性名，拼装成联合类型\\n```\\ntype MyObj = {\\n    foo: number,\\n    bar: string,\\n};\\ntype Keys = keyof MyObj; // 'foo'|'bar'\\n\\ninterface T {\\n    0: boolean;\\n    a: string;\\n    b(): void;\\n}\\ntype KeyT = keyof T; // 0 | 'a' | 'b'\\n```\\n对象键名只有三种类型，任意对象的键名联合类型为`string/number/symbol`\\n```\\ntype KeyT2 = keyof any; // string | number | symbol\\n```\\nobject没有自身的属性，没有键名\\n```\\ntype KeyT3 = keyof object;  // never\\n```\\n对象采用索引形式，keyof返回属性名的索引类型\\n```\\ninterface T2 {\\n    [prop: number]: number;\\n}\\ntype KeyT4 = keyof T; // number\\n\\n\\n```\\n属性名为字符串时包含了属性名为数值的情况\\n```\\ninterface T3 {\\n    [prop: string]: number;\\n}\\ntype KeyT5 = keyof T3; // string|number\\n```\\nkeyof 运算数组和元祖，会返回数组的所有键名，包括数字建明和继承的键名\\n```\\ntype Result = keyof ['a', 'b', 'c']; // number | \\\"0\\\" | \\\"1\\\" | \\\"2\\\" | \\\"length\\\" | \\\"pop\\\" | \\\"push\\\" | ...\\n```\\nkeyof运算联合类型，返回成员共有的键名， 交叉类型返回所有键名\\n```\\ntype A = { a: string; z: boolean };\\ntype B = { b: string; z: boolean };\\ntype KeyT6 = keyof (A | B); // 'z'\\n\\ntype A2 = { a: string; x: boolean };\\ntype B2 = { b: string; y: number };\\ntype KeyT7 = keyof (A2 & B2); // 'a' | 'x' | 'b' | 'y'\\n// 相当于\\n// (A2 & B2) === keyof A2 | keyof B2\\n```\\n##### keyof 使用场景\\n`keyof` 可以精确表达对象的属性类型\\n取出对象某个指定属性的值，使用`keyof`更加的准确\\n```\\n/ JS方式\\nfunction prop(obj, key) {\\n    return obj[key];\\n}\\n// TS\\nfunction prop<Obj, K extends keyof Obj>(obj: Obj, key: K): Obj[K] {\\n    return obj[key];\\n}\\n```\\n`keyof`还可以用于属性映射，将一个类型所有属性逐一映射为其它值\\n```\\ntype NewProps<Obj> = {\\n    [Prop in keyof Obj]: boolean;\\n};\\n// 用法\\ntype MyObj2 = { foo: number; };\\n// 等于 { foo: boolean; }, 将NewProps的类型都由number类型改为了boolean类型\\ntype NewObj = NewProps<MyObj2>;\\n```\\n去掉readonly 修饰符\\n```\\ntype Mutable<Obj> = {\\n    -readonly [Prop in keyof Obj]: Obj[Prop]; // -readonly表示去除这些属性的只读特性, +readonly则是添加只读属性\\n};\\ntype MyObj3 = {\\n    readonly foo: number;\\n}\\n// 等于 { foo: number; }\\ntype NewObj3 = Mutable<MyObj3>;\\n```\\n让可选属性变为必有属性\\n```\\ntype Concrete<Obj> = {\\n    [Prop in keyof Obj]-?: Obj[Prop]; // -?表示去除可选属性设置，+?表示添加可选属性设置\\n};\\ntype MyObj4 = {\\n    foo?: number;\\n}\\n// 等于 { foo: number; }\\ntype NewObj4 = Concrete<MyObj4>;\\n```\\n#### in 运算符\\nJS中的`in`用于判断对象是否包含某个属性名，TS中则是用于取出(遍历)联合类型的每一个成员，如上面用的案例`[Prop in keyof Obj]`\\n```\\ntype U = 'a' | 'b' | 'c';\\ntype Foo = {\\n    [Prop in U]: number;\\n};\\n// 等同于\\ntype Foo = {\\n    a: number,\\n    b: number,\\n    c: number\\n};\\n// JS中用法\\nconst obj = { a: 123 };\\nif ('a' in obj) console.log('found a');\\n```\\n#### 方括号运算符[]\\n方括号运算符用于取出对象的键值类型\\n```\\ntype Person = {\\n    age: number;\\n    name: string;\\n    alive: boolean;\\n};\\n\\ntype Age = Person['age']; // Age 的类型是 number\\n```\\n方括号里是联合类型，返回的也会是联合类型\\n```\\ntype TP = Person['age' | 'name']; // number|string\\ntype TPS = Person[keyof Person]; // number|string|boolean\\ntype TE = Person['notExisted']; // 报错, 不存在的属性会报错\\n```\\n方括号不能有值得运算\\n```\\nconst MyArray = ['a', 'b', 'c'];\\nconst key = 'age';\\ntype Age2 = Person[key]; // 报错\\ntype Age3 = Person['a' + 'g' + 'e']; // 报错\\n```\\n方括号参数可以是属性名的索引类型\\n```\\ntype Obj = {\\n    [key: string]: number,\\n};\\ntype Tn = Obj[string]; // number\\n```\\n#### extends...?: 条件运算符\\n根据当前类型是否符合某种条件，返回不同的类型\\n```\\nT extends U ? X : Y // T是否可以赋值给U，可以表达式结果为X，否则为Y\\ntype T = 1 extends number ? true : false; // true\\n\\ninterface Animal {\\n    live(): void;\\n}\\ninterface Dog extends Animal {\\n    woof(): void;\\n}\\ntype T1 = Dog extends Animal ? number : string; // number\\ntype T2 = RegExp extends Animal ? number : string; // string\\n```\\n#### infer 关键字\\n用来定义泛型中推断出来的类型参数，通常和条件运算符一起使用，用于`extends`关键字后面的父类型中\\n```\\ntype Flatten<Type> = Type extends Array<infer Item> ? Item : Type;\\ntype Str = Flatten<string[]>; // string\\ntype Num = Flatten<number>; // number\\n// 不使用infer则需要两个类型参数\\ntype Flatten2<Type, Item> = Type extends Array<Item> ? Item : Type;\\n```\\n使用info通过正则匹配提取类型参数\\n```\\ntype Str2 = 'foo-bar';\\ntype Bar = Str2 extends `foo-${infer rest}` ? rest : never // 'bar'\\n```\\n#### is 运算符\\n函数返回布尔值的时候，可以使用`is`运算符，限定返回值与参数之间的关系。\\n```\\nfunction isFish(pet: Fish | Bird): pet is Fish {\\n    // 参数pet类型为Fish，返回true，否则返回false\\n    return (pet as Fish).swim !== undefined;\\n}\\n```\\n`is`运算符通常用于描述函数的返回值类型，是否参数符合某种类型\\n```\\ntype A = { a: string };\\ntype B = { b: string };\\nfunction isTypeA(x: A | B): x is A {\\n    if ('a' in x) return true;\\n    return false;\\n}\\n```\\n#### 模板字符串\\nTS可以使用模板字符串构建类型，相当于内部可以引用其他类型\\n```\\ntype World = \\\"world\\\";\\ntype Greeting = `hello ${World}`; // \\\"hello world\\\"\\n```\\n模板字符串只能引用 `string`、`number`、`bigint`、`boolean`、`null`、`undefined`，除此之外都会报错\\n```\\ntype Num2 = 123;\\ntype Obj2 = { n: 123 };\\ntype T7 = `${Num2} received`; // 正确\\ntype T8 = `${Obj2} received`; // 报错\\n```\\n模板字符串可以展开联合类型也可以交叉展开两个类型\\n```\\ntype T = 'A' | 'B';\\ntype U = `${T}_id`; // \\\"A_id\\\"|\\\"B_id\\\"\\n\\ntype T = 'A' | 'B';\\ntype U = '1' | '2';\\ntype V = `${T}${U}`; // 'A1'|'A2'|'B1'|'B2'\\n```\\n\\n### 类型映射\\n> 类型映射是将一种类型按照映射规则，转换成另一种类型，通常用于对象类型\\n\\n上面案例中类型运算符`keyof` 写有部分案例\\n当两个对象属性结构一致，但是属性类型不一致，属性多时，逐个书写较为繁琐，这时我们可以使用类型映射，从类型`A`得到类型`B`\\n```\\ntype A = {\\n    foo: number;\\n    bar: number;\\n};\\ntype B = {\\n    [prop in keyof A]: string;\\n};\\n// 使用泛型，增加代码复用性\\ntype ToBoolean<Type> = {\\n    [Property in keyof Type]: boolean;\\n};\\n```\\n如上得到的B的类型，所有属性都是`string`\\n#### 修饰符\\n可以通过增加修饰符，更改原始属性的可选，只读属性\\n`+`修饰符：写成+?或+readonly，为映射属性添加`?`修饰符或`readonly`修饰符。 `+`可以省略\\n`–`修饰符：写成`-?`或`-readonly`，为映射属性移除`?`修饰符或`readonly`修饰符。\\n```\\ntype Optional<Type> = {\\n    [Prop in keyof Type]+?: Type[Prop];  // 添加可选属性\\n};\\ntype Concrete2<Type> = {\\n    [Prop in keyof Type]-?: Type[Prop]; // 移除可选属性\\n};\\ntype CreateImmutable<Type> = {\\n    +readonly [Prop in keyof Type]: Type[Prop]; // 添加 readonly\\n};\\ntype CreateMutable<Type> = {\\n    -readonly [Prop in keyof Type]: Type[Prop]; // 移除 readonly\\n};\\n```\\n#### 键名重映射\\n可以在映射键名的时候更改键名 `as + 新类型`，通常新类型为模板字符串，对原始类型进行操作\\n```\\ntype A = {\\n    foo: number;\\n    bar: number;\\n};\\ntype B = {\\n    [p in keyof A as `${p}ID`]: number;\\n};\\n// 等同于\\ntype B = {\\n    fooID: number;\\n    barID: number;\\n};\\n```\\n如上，在映射过程中，将A的键名更改掉，加上了字符串`ID`\\n\\n键名重映还可以过滤某些属性\\n```\\ntype User = {\\n    name: string,\\n    age: number\\n}\\ntype Filter<T> = {\\n    [K in keyof T as T[K] extends string ? K : never]: string\\n}\\ntype FilteredUser = Filter<User> // { name: string }\\n```\\n通过never，将不符合string类型的属性过滤掉\\n\\n### 注释指令\\n采用JS双斜杠注释的形式，向编译器发出命令\\n#### // @ts-nocheck\\n告诉编辑器不对当前脚本进行类型检查，可以用于TS，也可以用于JS，该指令只能写在脚本的顶部，写在代码后面则不会生效\\n```\\n// @ts-nocheck\\nconst element = document.getElementById(123);\\n```\\n#### // @ts-check\\n和上面相对应的在脚本顶部添加// ts-check，会告诉编辑器对其进行类型检查，无论是否启用 checkJS 选项\\n#### @ts-ignore\\n告诉编辑器不对下一行代码进行类型检查，可以用于TS、JS 脚本，相对来说该指令项目中较多使用\\n#### @ts-expect-error\\n主要用在测试用例，当下一行有类型错误时，它会压制 TypeScript 的报错信息（即不显示报错信息），把错误留给代码自己处理\\n如果下一行没有类型错误，`// @ts-expect-error`则会显示一行提示。`Unused '@ts-expect-error' directive.`\\n#### JSDoc\\nTS 直接处理JS文件，当无法推断出类型，会使用JS脚本里面的JSDoc 注释\\n\\n```\\n/**\\n * @param {string} somebody\\n */\\nfunction sayHello(somebody) {\\n    console.log('Hello ' + somebody);\\n}\\n```\\nJSDoc必须`/**`开始，JSDoc必须与描述代码出于相邻位置，并且注释在上，代码在下\\nTS支持大部分JSDoc声明，简单介绍几个\\n```\\n/**\\n * @typedef {(number | string)} NumberLike  // type NumberLike = string | number;\\n * @type {string} // 可以直接定义后面的变量类型\\n * @param {string}  x // 定义函数参数\\n * @param {string} [x=\\\"bar\\\"] // 加默认值\\n * @return {boolean} // 指定返回类型\\n * @extends {Base} // 定义继承的基类\\n * @public、@protected、@private分别指定类的公开成员、保护成员和私有成员。\\n * @readonly 指定只读成员。\\n * \\n */\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";"],"names":[],"sourceRoot":""}