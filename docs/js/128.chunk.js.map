{"version":3,"file":"js/128.chunk.js","mappings":"sIAAA,86J","sources":["webpack://source-map/./src/mds/TS/装饰器(旧版).md"],"sourcesContent":["export default \"本篇讲述旧版装饰器\\n\\n#### 装饰器环境\\n使用装饰器，需要打开如下配置，在tsconfig.json中配置\\n```\\n\\\"compilerOptions\\\": {\\n    \\\"experimentalDecorators\\\": true,\\n    \\\"emitDecoratorMetadata\\\": true\\n}\\n```\\n\\n#### 装饰器种类\\n装饰器根据装饰的不同对象，分为以下五类，\\n- 类装饰器(ClassDecorator)：用于类。\\n- 属性装饰器(PropertyDecorator)：用于属性。\\n- 方法装饰器(MethodDecorator)：用于方法。\\n- 存取器装饰器(AccessorDecorator )：用于类的 set 或 get 方法。\\n- 参数装饰器(ParameterDecorator)：用于方法的参数。\\n\\n装饰器只能用于类，要么用于类的主体，要么用于类的内部成员\\n使用示例如下\\n```\\n@ClassDecorator() // 类装饰器\\nclass A {\\n  @PropertyDecorator() // 属性装饰器\\n  name: string;\\n\\n  @MethodDecorator() // 方法装饰器\\n  fly(\\n    @ParameterDecorator() // 参数装饰器\\n    meters: number\\n  ) {\\n    // code\\n  }\\n\\n  @AccessorDecorator() // 存取器装饰器\\n  get egg() {\\n    // code\\n  }\\n  set egg(e) {\\n    // code\\n  }\\n}\\n```\\n\\n#### 类装饰器\\n类装饰器本质是用于类的构造方法，类装饰器有唯一的参数为构造方法，可以在内部对其构造方法进行改造，类装饰器有返回值会替换掉原来的构造方法\\n\\n源码中的类型定义\\n```\\ndeclare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;\\n\\nconst f: ClassDecorator = function (target: any) {\\n  console.log('hello decorator')\\n  return target;\\n}\\n\\n@f\\nclass A { }\\n// 输出：hello decorator\\n```\\n无需创建实例装饰器也会执行输出。装饰器是在代码加载阶段执行，且只执行一次，实际上装饰器是在编译阶段执行的函数\\n\\n 如果除了构造方法之外类装饰器还需要其余参数，可以用`工厂模式`将装饰器写在函数中\\n\\n```\\nfunction factory(info: string) {\\n  console.log('received: ', info);\\n  return function (target: any) {\\n    console.log('apply decorator');\\n    return target;\\n  }\\n}\\n\\n@factory('log something')\\nclass B { }\\n// factory方法返回的才是装饰器，故需要先执行一次函数， 装饰@后面可以是函数名，可以是函数表达式\\n```\\n\\n类装饰器可以没有返回值，如果有返回值会替代所装饰的类的构造函数，也就是可以返回一个新的类， 对原有的类进行修改或者扩展，类似于框架中的高阶组件\\n```\\nfunction decorator(target: any) {\\n  return class extends target {\\n    value = 123;\\n  };\\n}\\n@decorator\\nclass Foo {\\n  value = 456;\\n}\\nconst foo = new Foo();\\nconsole.log(foo.value); // 123\\n// 对decorator进行类型描述可以是如下\\ntype Constructor = {\\n  new(...args: any[]): {}\\n};\\n\\nfunction decorator2<T extends Constructor>(target: T) {\\n  return class extends target {\\n    value = 123;\\n  };\\n}\\n```\\n#### 方法装饰器\\n装饰类的方法MethodDecorator\\n```\\ndeclare type MethodDecorator = <T>(\\n  target: Object, \\n  propertyKey: string | symbol, \\n  descriptor: TypedPropertyDescriptor<T>\\n) => TypedPropertyDescriptor<T> | void;\\n```\\n接受三个参数\\n- target：（对于类的静态方法）类的构造函数，或者（对于类的实例方法）类的原型。\\n- propertyKey：所装饰方法的方法名，类型为string|symbol。\\n- descriptor：所装饰方法的描述对象。\\n\\n如下添加log的方法装饰器\\n```\\nfunction logger(\\n  target: any,\\n  propertyKey: string,\\n  descriptor: PropertyDescriptor\\n) {\\n  const original = descriptor.value;\\n\\n  descriptor.value = function (...args: number[]) {\\n    console.log('params: ', ...args);\\n    const result = original.call(this, ...args);\\n    console.log('result: ', result);\\n    return result;\\n  }\\n}\\n\\nclass C {\\n  @logger\\n  add(x: number, y:number ) {\\n    return x + y;\\n  }\\n}\\n\\n(new C()).add(1, 2)\\n// params:  1 2\\n// result:  3\\n```\\n#### 属性装饰器\\n```\\ndeclare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;\\n```\\n属性装饰器接受两个参数\\n- target: 类的原型对象，\\n- propertyKey: 所装饰属性的属性名，\\n\\n属性装饰器不需要返回值\\n```\\nfunction ValidRange(min:number, max:number) {\\n  return (target:Object, key:string) => {\\n    Object.defineProperty(target, key, {\\n      set: function(v:number) {\\n        if (v < min || v > max) {\\n          throw new Error(`Not allowed value ${v}`);\\n        }\\n      }\\n    });\\n  }\\n}\\n// 输出 Installing ValidRange on year\\nclass Student {\\n  @ValidRange(1920, 2020)\\n  year!: number;\\n}\\nconst stud = new Student();\\n// 报错 Not allowed value 2022 \\n// stud.year = 2022;\\n// console.log('aaastud', stud)\\n\\n// 如上通过属性装饰对赋值进行限制\\n```\\n#### 参数装饰器\\n用来装饰构造方法或者其他方法的参数，接受三个参数\\n```\\ndeclare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) => void;\\n```\\n- target: 类的构造方法\\n- propertyKey: 所装饰的方法的名字\\n- parameterIndex，当前参数在方法的参数序列位置(从0开始)\\n\\n参数装饰器无需返回值\\n```\\nfunction log(\\n  target: Object,\\n  propertyKey: string|symbol,\\n  parameterIndex: number\\n) {\\n  console.log(`${String(propertyKey)} NO.${parameterIndex} Parameter`);\\n}\\n\\nclass D {\\n  member(\\n    @log x:number,\\n    @log y:number\\n  ) {\\n    console.log(`member Parameters: ${x} ${y}`);\\n  }\\n}\\n\\nconst d = new D();\\nd.member(5, 5);\\n// member NO.1 Parameter\\n// member NO.0 Parameter \\n// member Parameters: 5 5 \\n```\\n\\n#### 装饰器执行顺序\\n装饰器在代码解析时执行切只执行一次，执行顺序如下\\n1. 实例相关的装饰器。\\n2. 静态相关的装饰器。\\n3. 构造方法的参数装饰器。\\n4. 类装饰器。\\n```\\nfunction fn(key:string):any {\\n  return function () {\\n    console.log('执行：', key);\\n  };\\n}\\n\\n@fn('类装饰器')\\nclass E {\\n  @fn('静态方法')\\n  static method() {}\\n  @fn('静态方法2')\\n  static method2() {}\\n  \\n  @fn('实例方法')\\n  method() {}\\n  @fn('实例方法2')\\n  @fn('实例方法装饰2-2')\\n  method2() {\\n\\n  }\\n\\n  constructor(@fn('构造方法参数') foo:any) {}\\n}\\n// 执行： 实例方法\\n// 执行： 实例方法装饰2-2\\n// 执行： 实例方法2\\n// 执行： 静态方法\\n// 执行： 静态方法2\\n// 执行： 构造方法参数\\n// 执行： 类装饰器\\n```\\n当有多个实例方法或静态方法，按照装饰器的执行顺序从上到下依次执行\\n一个方法可以用多个装饰器，从下往上执行，顺序加载，逆序执行\\n\\n\\n#### 其它\\n关于装饰器不能作用于函数是因为在JS中，函数会提升，无论函数代码在什么位置，都会提升到代码顶部\\n而类不存在这样的问题，所以可以用于类\\n\\n\\n多个装饰器应用于同一目标，可以写在一行也可以写在多行\\n```\\n// 一行\\n@f @g x\\n// 多行\\n@f\\n@g\\nx\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\";"],"names":[],"sourceRoot":""}