{"version":3,"file":"js/722.chunk.js","mappings":"sIAAA,6hH","sources":["webpack://source-map/./src/mds/TS/泛型.md"],"sourcesContent":["export default \"#### 简介\\n>当函数返回值类型与参数类型相关，不用具体类型和any表示，我们可以使用泛型generics来实现\\n\\n泛型就是类型参数, 返回值类型与参数类型相关,或者不需要表明具体类型,但是内部使用相同类型的参数\\n```\\nfunction getFirst<T>(arr: T[]): T {\\n    return arr[0];\\n}\\n\\ngetFirst<number>([1, 2, 3])\\ngetFirst([1, 2, 3])\\n```\\n上面案例`<T>`就是类型参数，参数放在尖括号里面，`T` 可以随意取值，一般是用`Type`的简写`T`\\n上面参数就是类型`T`的数组，返回类型为`T`，调用时可以自己指定类型，也可以让TS自己进行类型推断\\n\\n类型推断失灵时就需要手动指定入参类型\\n```\\nfunction comb<T>(arr1: T[], arr2: T[]): T[] {\\n    return arr1.concat(arr2);\\n}\\ncomb([1, 2], ['a', 'b']) // 报错\\ncomb<number | string>([1, 2], ['a', 'b']) // 正确\\n```\\n多个类型参数\\n```\\nfunction map<T, U>(\\n    arr: T[],\\n    f: (arg: T) => U\\n): U[] {\\n    return arr.map(f);\\n}\\nmap<string, number>(\\n    ['1', '2', '3'],\\n    (n) => parseInt(n)\\n); // 返回 [1, 2, 3]\\n```\\n泛型可以理解成类型逻辑，需要类型参数表达，使输入类型和输出类型可以建立对应关系\\n\\n#### 泛型的写法\\n泛型主要用在函数、接口、类和别名\\n##### 函数泛型写法\\n```\\n// 正常function定义的泛型函数\\nfunction id<T>(arg: T): T {\\n    return arg;\\n}\\n// 变量定义的泛型函数\\nlet myId: <T>(arg: T) => T = id;\\nlet myId2: { <T>(arg: T): T } = id;\\n```\\n##### 接口泛型写法\\n```\\ninterface Box<Type> {\\n    contents: Type;\\n}\\nlet box: Box<string> = {\\n    contents: 'asdfas'\\n}\\n\\ninterface Comparator<T> {\\n    compareTo(value: T): number;\\n}\\nclass Rectangle implements Comparator<Rectangle> {\\n    compareTo(value: Rectangle): number {\\n        // ...\\n        return 34\\n    }\\n}\\n```\\n函数接口泛型写法，不指定具体的函数\\n```\\ninterface Fn {\\n    <Type>(arg: Type): Type;\\n}\\nfunction id2<Type>(arg: Type): Type {\\n    return arg;\\n}\\nlet myId3: Fn = id2;\\n```\\n##### 类的泛型写法\\n泛型类的类型参数在类名后面\\n```\\nclass Pair<NumType> {\\n    value!: NumType;\\n    add!: (x: NumType, y: NumType) => NumType;\\n\\n    // 需要注意的是泛型类是类的实例，不包括静态属性和静态方法\\n    static data: NumType;  // 报错\\n}\\n// 继承时要给出具体的类型，所以写成any\\nclass B extends Pair<any> {\\n}\\nlet foo = new Pair<number>();\\nfoo.value = 0;\\nfoo.add = function (x, y) {\\n    return x + y;\\n};\\n```\\n##### 类型别名的泛型写法\\n```\\ntype Nullable<T> = T | undefined | null;\\n\\ntype Container<T> = { value: T };\\nconst a: Container<number> = { value: 0 };\\nconst b: Container<string> = { value: 'b' };\\n// 树形结构泛型\\ntype Tree<T> = {\\n    value: T;\\n    left: Tree<T> | null;\\n    right: Tree<T> | null;\\n};\\n```\\n#### 类型参数默认值\\n类型参数可以设置默认自，当没有给出类型参数的值会用默认值\\n\\n```\\nfunction getFirst2<T = string>(arr: T[]): T {\\n    return arr[0];\\n}\\ngetFirst2([1, 2, 3]) // 正确，有具体类型时会覆盖默认类型\\n\\nclass Generic<T = string> {\\n    list: T[] = []\\n    add(t: T) {\\n        this.list.push(t)\\n    }\\n}\\n//   实例化是没有给出具体的类型，会按照默认类型判断\\nconst g = new Generic();\\ng.add(4) // 报错\\ng.add('hello') // 正确\\n```\\n多个类型参数时，有默认值的类型参数需要放在后面，有默认值代表可选参数\\n```\\n<T = boolean, U> // 错误\\n<T, U = boolean> // 正确\\n```\\n#### 数组的泛型表示\\nTS内部，Array是一个泛型接口，类型基本如下\\n```\\ninterface Array<Type> {\\n    length: number;\\n    pop(): Type | undefined;\\n    push(...items: Type[]): number;\\n    // ...\\n}\\n```\\n像是`Array<T>`,`Array<number>`,`Array<string>`都是泛型写法，`number[]`, `string[]`是其简写形式\\n\\n只读数组的泛型写法为`ReadonlyArray<T>`\\n```\\nfunction doStuff(values: ReadonlyArray<string>) {\\n    values.push('hello!');  // 报错\\n}\\n```\\nTS内部结构的Map，Set，Promise都是泛型接口Map<K, V>、Set<T>和Promise<T>\\n\\n#### 类型参数的约束\\n类型参数可以使用`extends`进行条件约束`<TypeParameter extends ConstraintType>`\\n```\\nfunction comp<T extends { length: number }>(a: T, b: T) {\\n    if (a.length >= b.length) {\\n        return a;\\n    }\\n    return b;\\n}\\ncomp([1, 2], [1, 2, 3]) // 正确\\ncomp('ab', 'abc') // 正确\\ncomp(1, 2) // 报错\\n```\\n类型参数可以同时设置约束条件和默认值\\n```\\ntype Fn2<A extends string, B extends string = 'world'> =  [A, B];\\ntype Result = Fn2<'hello'> // [\\\"hello\\\", \\\"world\\\"]\\n```\\n#### 类型参数的使用注意点\\n1、尽量少用泛型，泛型会加大代码复杂性，难读难写，如无必要，不用泛型\\n2、类型参数越少越好\\n3、类型参数至少出现两次，如果只出现一次，很可能不是必要的\\n\\n\\n\\n\\n\";"],"names":[],"sourceRoot":""}