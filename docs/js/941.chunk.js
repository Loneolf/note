"use strict";(self.webpackChunksource_map=self.webpackChunksource_map||[]).push([[941],{33941:(n,e,t)=>{t.r(e),t.d(e,{default:()=>r});const r="### 简介\n#### 函数的类型声明\n和JS相比增加了参数类型和返回值类型，`void`标识表示没有任何返回\n```\nfunction hello(txt: string): void {\n\tconsole.log(\"hello \" + txt);\n}\n```\n如果函数没有返回值，不添加`:void`也会类型推断返回值为`void`\n```\nfunction hello2(txt: string) {\n\tconsole.log(\"hello \" + txt);\n}\n```\n\n#### 变量函数赋值写法\n```\n// 写法一\nconst hello3 = function (txt: string) {\n\tconsole.log(\"hello \" + txt);\n};\n// 写法二, 类型和参数名必须放在括号中,没有参数名txt 会推断string为any类型\nconst hello4: (txt: string) => void = function (txt) {\n\tconsole.log(\"hello \" + txt);\n};\n```\n#### type定义函数类型别名\n```\ntype MyFunc = (txt:string) => void;\nconst hello5:MyFunc = function (txt) {\n  console.log('hello ' + txt);\n}\n```\n\n函数也可以用typeof 提取类型， myAdd和add类型相同，可以用typeof 提取add的函数类型\n```\nfunction add( x:number, y:number ) {\n    return x + y;\n}\nconst myAdd:typeof add = function (x, y) {\n    return x + y;\n```\n\n#### 函数参数\n函数参数可以少写，允许参数不足，不能多写，\n\n```\nlet myFunc: (a:number, b:number) => number;\nmyFunc = (a:number) => a; // 正确\nmyFunc(4) // 调用的时候需要传两个参数，一个会报错\nmyFunc = (a:number, b:number, c:number ) => a + b + c; // 报错\n```\n\n#### 函数类型的对象写法\n当函数本身存在属性时，可以使用该写法，使用较少\n\n```\n{\n    (参数列表): 返回值\n}\nlet add2:{\n    (x:number, y:number):number,\n    version: string\n};\nfunction addf (x: number, y: number) {\n    return x + y;\n};\naddf.version = '5.0'\nadd2 = addf\n```\n\n### 函数具体分类及详情\n#### Function 类型\nFunction就是函数类型，可表示任何函数，接收任意参数，没个参数都是any类型，返回值也是any，无任何约束，不建议使用\n\n```\nfunction doSomething(f:Function) {\n    return f(1, 2, 3);\n}\n```\n\n#### 箭头函数\n箭头函数就是普通函数的简化写法，和普通函数类似\n\n```\nconst repeat = ( str:string, times:number ):string => str.repeat(times);\n```\n箭头函数参数，void写在箭头后面\n\n```\nfunction greet( fn:(a:string) => void ):void {\n    fn('world');\n}\n```\n带有返回类型的箭头函数\n\n```\ntype Person1 = { name: string };\nconst people = ['alice', 'bob', 'jan'].map(\n  (name):Person1 => ({ name })\n);\n```\n\n#### 可选参数\n可以省略的参数， 可选参数只能放在参数列表中必选参数的后面\n```\nfunction f2(x?:number) { // x的类型等同于 number | undefined\n    // ...\n}\nf2(); // OK\nf2(10); // OK\nf2(undefined) // OK \n```\n\n#### 参数默认值\n与JS一致，不传入参数时取默认值，\n有参数默认值可以省略不传，也可以省略类型声明，可以通过默认值进行类型推断\n可选参数与默认值不能同时使用\n\n```\nfunction createPoint( x:number = 0, y:number = 0 ):[number, number] {\n    return [x, y];\n}\ncreatePoint() // [0, 0]\n\n```\n#### 参数解构\n\n```\ntype ABC = { a:number; b:number; c:number };\nfunction sum({ a, b, c }:ABC) {\n  console.log(a + b + c);\n}\n```\n\n#### rest 参数\n函数剩余的所有参数，可以是数组或者元组\n \nrest 参数为数组\n```\nfunction multiply(n:number, ...m:number[]) {\n    return m.map((x) => n * x);\n  }\n```\nrest 参数为元组, 可选参数后面加个?\n\n```\nfunction f3(...args:[boolean, number?]) {\n    // ...\n}\n```\nrest 参数解构\n\n```\nfunction repeat2(...[str, times]:[string, number] ):string {\n    return str.repeat(times);\n}\n// 等同于如下\nfunction repeat3( str: string, times: number ):string {\n    return str.repeat(times);\n}\n```\n#### 只读参数\n参数至刻度，不能更改，较少用\n\n```\nfunction arraySum( arr:readonly number[] ) {\n    // ...\n    arr[0] = 0; // 报错\n}\n```\n\n#### void 类型\n没有返回值的函数，\n因为函数没有返回值默认是undefined，所以，void函数返回undefined可以\n\n```\nfunction f4():void {\n    console.log('hello');\n}\nfunction f5():void {\n    return undefined; // 正确\n}\nfunction f6():void {\n    return null; // 严格模式下错误，非严格模式下可以返回null(strictNullChecks)\n}\n```\n函数运行错误抛出异常，可以将返回值写成void\n\n```\nfunction throwErr():void {\n    throw new Error('something wrong');\n}\n```\n\n#### never 不会出现的值\n函数出现异常或者陷入死循环，无法返回正常的值，返回值类型就是never\n\n```\nfunction fail(msg:string):never {\n    throw new Error(msg);\n}\n\nconst sing = function():never {\n    while (true) {\n        console.log('sing');\n    }\n};\n```\n返回错误并不是never\n\n```\nfunction failReturn():Error { \n    return new Error(\"Something failed\");\n}\n```\n函数仅在某些条件下抛出异常，返回值可以省略never\nnerve是TS的底层类型，所有类型都包含nerve\n\n```\nfunction sometimesThrow():number {\n    if (Math.random() > 0.5) {\n        return 100;\n    }\n    throw new Error('Something went wrong');\n  }\nconst result = sometimesThrow();\n```\n\n#### 高阶函数\n函数的返回值是函数，那么前一个函数就是高阶函数\n```\n(someValue: number) => (multiplier: number) => someValue * multiplier;\n```\n类似的高阶组件也是相同概念，接受一个组件，返回一个组件\n#### 函数重载\n函数可以接受不同类型或不同个数的参数，并根据参数的不同执行不同的函数行为，称之为函数重载\n```\nfunction makeDate(timestamp: number): Date\nfunction makeDate(m: number, d: number, y: number): Date\nfunction makeDate(mOrTimestamp: number, d?: number, y?: number): Date {\n  if (d !== undefined && y !== undefined) {\n    return new Date(y, mOrTimestamp, d)\n  } else {\n    return new Date(mOrTimestamp)\n  }\n}\n\nconst d1 = makeDate(12345678) // 正常\nconst d2 = makeDate(5, 6, 7) // 正常\nconst d3 = makeDate(5, 9) // 报错\n```\n如上，mackData函数，只能接受一个或者三个参数，不能接受两个参数，只能执行重载的的函数类型\n\n函数重载参数可以使用字符串或者数组，但是不能使用可能存在的参数，因为TS只能使用一个函数解析重载\n\n```\nfunction len(s: string): number\nfunction len(arr: any[]): number\nfunction len(x: any) {\n  return x.length\n}\nlen('hello') // OK\nlen([1, 2, 3]) // OK \nlen(Math.random() > 0.5 ? 'hello' : [4, 5, 6]) // 错误\n```\n重载是比较复杂的类型声明，如果可以，应优先使用联合类型替代函数重载，除非多个参数、或者某个参数与返回值存在对应关系\n\n```\nfunction len(x: any[] | string) {\n   return x.length\n}\n```\n#### 构造函数\n构造函数使用new关键字，类的本质也是构造函数\n\n```\nclass Animal {\n    numLegs:number = 4;\n}\ntype AnimalConstructor = new () => Animal; // AnimalConstructor:构造函数\nfunction create(c:AnimalConstructor):Animal {\n    return new c();\n}\nconst aa = create(Animal);\n```\n\n既可以是构造函数，也可以是普通函数的对象写法\n```\ntype F = {\n    new (s:string): object;\n    (n?:number): number;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}}]);
//# sourceMappingURL=941.chunk.js.map