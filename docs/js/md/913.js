"use strict";(self.webpackChunksource_map=self.webpackChunksource_map||[]).push([[913],{75913:(n,e,t)=>{t.r(e),t.d(e,{default:()=>l});const l='#### 构建性能优化\n随着项目越来越大， 功能和业务代码越来越多，`webpack`构建优化越来越有必要，通常优化配置如下\n##### 通用环境\n1. 更新到最新版本，webpack，nodejs，npm等，较新版本更高效的构建模块树以及提高解析速度\n2. 优化`loader`配置: 在使用`loader`时，可以通过配置`include`、`exclude`、`test`属性来匹配文件，使用`include`、`exclude`规定哪些匹配应用loader\n3. 解析\n    - 减少`resolve.modules`，`resolve.extensions`，`resolve.mainFiles`，`resolvedescriptionFiles`中条目数量，它们会增加文件系统的调用次数\n    - 如果不适用symlinks（如npm link或yarn link），可以设置resolve.symlinks:false\n    - 如果使用自定义resolve plugin规则，并且没有指定context上下文，可以设置resolve。cacheWithContext: false\n4. 保持编译结果的整体大小，让chunk体积小\n    - 使用数量更少/体积更小的`library`\n    - 在SPA中使用`SplitChunksPlugin`，并开启`saync`模式\n    - 移除未使用代码\n    - 只编译当前正在开发的代码\n\n5. 使用`resolve.alias`, 路径别名，通过配置alias减少查找过程\n\n6. 使用缓存\n    - 在性能开销较大的`loader`之前添加`cashe-loader`,将结果缓存到磁盘中，提升二次构建速度`use: [\'cache-loader\', ...loaders],`\n    - webpack中配置`cache`， `module.exports = { cache: {type: "memory"}}`\n7. 移除`process plugin`，可以看到构建过程，但是不会为快速构建提供太多价值\n8. dll 动态链接库\n> 使用DllPlugin 为更改不频繁的代码单独生产编译结果，提高应用程序的编译速度，通常是一些依赖包，使用dll编译一次，之后就不需要为这些依赖包再编译\n\n配置步骤\n- 单独配置一个配置文件打包不会发生变化的第三方库webpack.config.dll.js：\n- 通过插件将打包好的库引入到界面上,add-asset-html-webpack-plugin\n- 生成动态库的映射关系（清单），方便webpack能够从中找到对应的库,DllPlugin\n- 告诉webpack去哪里查找动态库\n\nwebpack.config.dll.js文件如下\n```\nconst path = require("path");\nconst webpack = require("webpack");\nmodule.exports = {\n  mode: "production",\n  // 配置的是node_modules里安装的第三方的包\n  entry: {\n    // 示例，将lodash和jquery单独打包，这样正常启动就不用为这两个包编译了\n    vendor: ["lodash", "jquery"],\n  },\n  output: {\n    filename: "[name].js",\n    path: path.resolve(__dirname, "dll"),\n    library: "[name]_[hash]",\n  },\n  plugins: [\n    new webpack.DllPlugin({\n      // 映射关系文件名\n      name: "[name]_[hash]",\n      // 映射关系表，manifest.json文件\n      path: path.resolve(__dirname, "dll/manifest.json"),\n    }),\n  ],\n};\n\n// package.json添加编译指令\n"scripts": {\n    ...\n    "dll": "npx webpack --config ./webpack.dll.config.js"\n}\n```\n在webpack中需要通过`webpack.DllReferencePlugin`插件告知webpack哪些依赖不需要编译打包，通过插件`add-asset-html-webpack-plugin`插件将链接动态注入到生成的`html`中\n\n配置如下\n```\nplugins: [\n\tnew webpack.DllReferencePlugin({\n\t\tmanifest: path.resolve(__dirname, "./dll/manifest.json"),\n\t}),\n\tnew AddAssetHtmlPlugin({\n\t\tfilepath: path.resolve(__dirname, "./dll/vendor.js"),\n\t\tpublicPath: "./",\n\t}),\n],\n```\n\n\n9. worker pool 多线程打包\n可以通过`thread-loader`插件，将比较耗资源的loader单独分流给worker pool，相当于另开一个线程处理耗资源的loader\n\n示例配置如下，处理ES6\n```\nmodule.exports={\n\t...\n\tmodule:{\n\t\trules:[\n\t\t\t{\n\t\t\t\ttest:/\\.js$/,\n\t\t\t\texclude:/node_modules/,\n\t\t\t\tuse:[\n\t\t\t\t\t{\n\t\t\t\t\t\tloader:\'babel-loader\',\n\t\t\t\t\t\toptions:{\n\t\t\t\t\t\t\tpresets:[\'@babel/preset-env\']\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n                    {\n                        loader:\'thread-loader\',\n                        options:{\n                            workers:2 // 调用CPU核心数\n                        }\n                    }\n\t\t\t\t]\n\t\t\t}\n\t\t]\n\t}\n}\n```\n\n\n##### 开发环境\n1. 增量编译\n使用webpack的watch mode（监听模式），而不使用其他工具来watch文件和调用webpack。内置的watch mode会记录时间戳并将此信息传递给compilation以使缓存失效。\n某些配置环境中，watch mode会回退到poll mode（轮询模式）。监听许多文件会导致CPU大量负载。在这些情况下，可以使用watchOptions.poll 来增加轮询的间隔时间。\n\n2. 在内存中编译\n下面几个工具通过咋内存中（而不是写入磁盘）编译和serve资源来提高性能\n    - webpack-dev-server\n    - webpack-hot-middleware\n    - webpack-dev-middleware\n\n3. devtool\n需要注意的是不同的devtool设置，会导致性能差异。\n    - eval：性能最好，但不能转译代码\n    - cheap-source-map：较差一点的map质量\n    - eval-source-map：增量编译\n    在大多数情况下，最佳选择是eval-cheap-module-source-map\n\n4. 避免在生产环境才用到的工具\n某些utility, plugin和loader都只用于生产环境。例如，在开发环境下使用TerserPlugin 来 minify(压缩)和mangle(混淆破坏)代码。通常在开发环境下，应该排除以下这些工具∶\n    - TerserPlugin\n    - [fullhash]/[chunkhash]/[contenthash].\n    - AggressiveSplittingPlugin\n    - .AggressiveMergingPlugin\n    - ModuleConcatenationPlugin\n\n5. 最小化entry chunk\nWebpack只会在文件系统中输出已经更新的chunk。某些配置选项（HMR，output.chunkFilename 的[name]/[chunkhash]/[contenthash]，[fullhash]）来说，除了对已经更新的 chunk无效之外，对于entry chunk 也不会生效。\n确保在生成entry chunk时，尽量减少其体积以提高性能。以下配置为运行时代码创建了一个额外的chunk，所以生成代价较低:\n```\nmodule.exports = {\n    optimization:{\n        runtimeChunk: true,\n    }\n}\n```\n6. 避免额外的优化步骤\nWebpack通过执行额外的算法任务，来优化输出结果的体积和加载性能。这些优化适用于小型代码库，但是在大型代码库中却非常耗费性能\n```\nmodules.exports = {\n    optimizations: {\n        remoAvailabelModules: false,\n        remoEmptyChunks: false,\n        splitChunks: false,\n    }\n}\n```\n\n7. 输出结果不携带路径信息\nWebpack 会在输出的bundle 中生成路径信息。然而，在打包数干个模块的项目中，这会导致造成垃圾回收性能压力。\n```\nmodule.exports = {\n    output: {\n        pathinfo: false,\n    }\n}\n```\n8. typescript loader\n可以为loader传入transpileOnly选项，以缩短使用ts-loader时的构建时间。使用此选项，会关闭类型检查。如果要再次开启类型检查，使用ForkTsCheckerWebpackPlugin。使用此插件会将检查过程移至单独的进程，可以加快TypeScript 的类型检查和 ESLint插入的速度。\n```\n{\n    test: /\\.tsx$/,\n    use: [\n      {\n        loader: "ts-loader",\n        options: {\n          transpileOnly: true,\n        },\n      },\n    ],\n  },\n```'}}]);
//# sourceMappingURL=913.js.map