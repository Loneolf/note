"use strict";(self.webpackChunksource_map=self.webpackChunksource_map||[]).push([[88],{9088:(n,t,s)=>{s.r(t),s.d(t,{default:()=>e});const e="# 第2章 栈\n\n数组是一个线性结构，并且可以在数组的任意位置插入和删除元素。\n\n但是有时候，我们为了实现某些功能，必须对这种任意性加以限制。\n\n栈和队列就是比较常见的受限的线性结构。\n\n## 什么是栈\n\n栈（stack）是一种运算受限的线性表：\n\n- `LIFO（last in first out）`表示就是后进入的元素，第一个弹出栈空间。类似于自动餐托盘，最后放上的托盘，往往先拿出去使用。\n- 其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。\n- 向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；\n- 从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。\n\n如下图所示：\n![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.71xt32okr3k0.png)\n\n栈的特点：**先进后出，后进先出**。\n\n## 程序中的栈结构\n\n- 栈被用在编程语言的编译器和内存中保存变量、方法调用等，也被用于浏览器历史记录（浏览器的返回按钮）。\n- 函数调用栈：A(B(C(D())))：\n  即 A 函数中调用 B，B 调用 C，C 调用 D；在 A 执行的过程中会将 A 压入栈，随后 B 执行时 B 也被压入栈，函数 C 和 D 执行时也会被压入栈。所以当前栈的顺序为：A->B->C->D（栈顶）；函数 D 执行完之后，会弹出栈被释放，弹出栈的顺序为 D->C->B->A;\n- 递归：\n  为什么没有停止条件的递归会造成栈溢出？比如函数 A 为递归函数，不断地调用自己（因为函数还没有执行完，不会把函数弹出栈），不停地把相同的函数 A 压入栈，最后造成栈溢出（Queue Overfloat）。\n\n## 练习\n\n题目：有 6 个元素 6，5，4，3，2，1 按顺序进栈，问下列哪一个不是合法的出栈顺序？\n\n- A：5 4 3 6 1 2 （√）\n- B：4 5 3 2 1 6 （√）\n- C：3 4 6 5 2 1 （×）\n- D：2 3 4 1 5 6 （√）\n\n题目所说的按顺序进栈指的不是一次性全部进栈，而是有进有出，进栈顺序为 6 -> 5 -> 4 -> 3 -> 2 -> 1。\n\n解析：\n\n- A 答案：65 进栈，5 出栈，4 进栈出栈，3 进栈出栈，6 出栈，21 进栈，1 出栈，2 出栈（整体入栈顺序符合 654321）。\n- B 答案：654 进栈，4 出栈，5 出栈，3 进栈出栈，2 进栈出栈，1 进栈出栈，6 出栈（整体的入栈顺序符合 654321）。\n- C 答案：6543 进栈，3 出栈，4 出栈，之后应该 5 出栈而不是 6，所以错误。\n- D 答案：65432 进栈，2 出栈，3 出栈，4 出栈，1 进栈出栈，5 出栈，6 出栈。符合入栈顺序。\n\n## 栈结构实现\n\n### 栈常见的操作\n\n- `push()` 添加一个新元素到栈顶位置。\n- `pop()` 移除栈顶的元素，同时返回被移除的元素。\n- `peek()` 返回栈顶的元素，不对栈做任何修改（该方法不会移除栈顶的元素，仅仅返回它）。\n- `isEmpty()` 如果栈里没有任何元素就返回 `true`，否则返回 `false`。\n- `size()` 返回栈里的元素个数。这个方法和数组的 `length` 属性类似。\n- `clear()` 移除栈里的所有元素。\n- `toString()` 将栈结构的内容以字符串的形式返回。\n\n### 创建一个基于数组的栈\n\n```js\nclass StackArray {\n  // 用数组来保存栈内元素\n  constructor() {\n    this.items = []\n  }\n\n  // 栈的相关操作\n\n  // 1.添加一个（或几个）新元素到栈顶\n  push(element) {\n    this.items.push(element)\n  }\n\n  // 2.移除栈顶的元素，同时返回被移除的元素\n  pop() {\n    return this.items.pop()\n  }\n\n  // 3.返回栈顶的元素，不对栈做任何修改\n  peek() {\n    return this.items[this.items.length-1]\n  }\n\n  // 4.判断栈是否为空，如果栈里没有任何元素就返回true，否则返回false\n  isEmpty() {\n    return this.items.length === 0\n  }\n\n  // 5.获取栈中元素个数\n  size() {\n    return this.items.length\n  }\n\n  // 6.移除栈里所有元素\n  clear() {\n    this.items = []\n  }\n\n  // 7.toString方法\n  toString() {\n    let resultString = ''\n    for (const item of this.items) {\n      resultString += item + ' '\n    }\n    return resultString\n  }\n}\n```\n\n### 测试封装的栈结构\n\n```js\n// push() 测试\nstack.push(1);\nstack.push(2);\nstack.push(3);\nconsole.log(stack.items); //--\x3e [1, 2, 3]\n\n// pop() 测试\nconsole.log(stack.pop()); //--\x3e 3\n\n// peek() 测试\nconsole.log(stack.peek()); //--\x3e 2\n\n// isEmpty() 测试\nconsole.log(stack.isEmpty()); //--\x3e false\n\n// size() 测试\nconsole.log(stack.size()); //--\x3e 2\n\n// toString() 测试\nconsole.log(stack.toString()); //--\x3e 1 2\n```\n\n## 栈结构的简单应用\n\n栈的实际应用非常广泛。在回溯问题中，它可以存储访问过的任务或路径、撤销的操作。Java和C#用栈来存储变量和方法调用，特别是处理递归算法时，有可能抛出一个栈溢出异常。\n\n既然我们已经了解了Stack类的用法，不妨用它来解决一些计算机科学问题。利用栈结构的特点封装实现十进制转换为二进制的方法。\n\n现实生活中，我们主要使用十进制。但在计算科学中，二进制非常重要，因为计算机里的所有内容都是用二进制数字表示的（0和1）。没有十进制和二进制相互转化的能力，与计算机交流就很困难。\n\n分析：把十进制转换为二进制的通用方法就是模二取余法，将十进制数字不断模二取余，直到被除数等于零时停止，将得到的余数逆序输出即为相应二进制数字。\n\n### 代码实现\n\n```js\nfunction dec2bin(decNumber) {\n  // 1.定义栈对象\n  let stack = new StackArray()\n\n  // 2.循环取余压栈\n  while (decNumber > 0) {\n    stack.push(decNumber % 2)\n    decNumber = Math.floor(decNumber / 2)\n  }\n\n  // 3.按顺序出栈显示结果\n  let binaryString = ''\n  while (!stack.isEmpty()) {\n    binaryString += stack.pop()\n  }\n  return binaryString\n}\n```\n\n### 测试\n\n```js\n// dec2bin() 测试\nconsole.log(dec2bin(100)); //--\x3e 1100100\nconsole.log(dec2bin(88)); //--\x3e 1011000\nconsole.log(dec2bin(233)); //--\x3e 11101001\n```\n\n## 创建一个基于JavaScript对象的栈\n\n创建一个Stack类最简单的方式是使用一个数组来存储其元素。在处理大量数据的时候（这在现实生活中的项目里很常见），我们同样需要评估如何操作数据是最高效的。在使用数组时，大部分方法的时间复杂度是O(n)。O(n)的意思是，我们需要迭代整个数组直到找到要找的那个元素，在最坏的情况下需要迭代数组的所有位置，其中的n代表数组的长度。如果数组有更多元素的话，所需的时间会更长。另外，数组是元素的一个有序集合，为了保证元素排列有序，它会占用更多的内存空间。\n\n如果我们能直接获取元素，占用较少的内存空间，并且仍然保证所有元素按照我们的需要排列，那不是更好吗？对于使用JavaScript语言实现栈数据结构的场景，我们也可以使用一个JavaScript对象来存储所有的栈元素，保证它们的顺序并且遵循LIFO原则。我们来看看如何实现这样的行为。\n\n```js\nclass Stack {\n  constructor() {\n    // count属性记录栈的大小\n    this.count = 0\n    this.items = {}\n  }\n}\n//完整实现详见src/Stack/stack.js\n```\n\n## 保护数据结构内部元素\n\n在创建别的开发者也可以使用的数据结构或对象时，我们希望保护内部的元素，只有我们暴露出的方法才能修改内部结构。对于Stack类来说，要确保元素只会被添加到栈顶，而不是栈底或其他任意位置（比如栈的中间）。不幸的是，我们在Stack类中声明的items和count属性并没有得到保护，因为JavaScript的类就是这样工作的。\n\n我们使用ES2015（ES6）语法创建了Stack类。ES2015类是基于原型的。尽管基于原型的类能节省内存空间并在扩展方面优于基于函数的类，但这种方式不能声明私有属性（变量）或方法。另外，在本例中，我们希望Stack类的用户只能访问我们在类中暴露的方法。下面来看看其他使用JavaScript来实现私有属性的方法。\n\n### 下划线命名约定\n\n一部分开发者喜欢在JavaScript中使用下划线命名约定来标记一个属性为私有属性。\n\n```js\nclass Stack{\n  constructor(){\n    this._count = 0\n    this._items = {}\n  }\n}\n```\n\n下划线命名约定就是在属性名称之前加上一个下划线（_）。不过这种方式只是一种约定，并不能保护数据，而且只能依赖于使用我们代码的开发者所具备的常识。\n\n### 用ES2015的限定作用域Symbol实现类\n\nES2015新增了一种叫作Symbol的基本类型，它是不可变的，可以用作对象的属性。看看怎么用它在Stack类中声明items属性（我们将使用数组来存储元素以简化代码）。\n\n```js\nconst _items = Symbol('stackItems');\nclass Stack {\n  constructor() {\n    this[_items] = [];\n  }\n  //栈的方法\n}\n```\n\n在上面的代码中，我们声明了Symbol类型的变量items，在类的constructor函数中初始化它的值。要访问items，只需要把所有的this.items都换成this[_items]。\n\n这种方法创建了一个假的私有属性，因为ES2015新增的Object.getOwnPropertySymbols方法能够取到类里面声明的所有Symbols属性。\n\n### 用ES2015的WeakMap实现类\n\n有一种数据类型可以确保属性是私有的，这就是WeakMap。WeakMap可以存储键值对，其中键是对象，值可以是任意数据类型。\n\n如果用WeakMap来存储items属性（数组版本）, Stack类就是这样的：\n\n```js\nconst items = new WeakMap();\nclass Stack {\n  constructor() {\n    items.set(this, []);\n  }\n  push(element){\n    const s = items.get(this);\n    s.push(element)\n  }\n    pop(){\n      const s = items.get(this);\n      const r = s.pop();\n      return r\n    }\n    //其它方法\n}\n```\n\n现在我们知道了，items在Stack类里是真正的私有属性。采用这种方法，代码的可读性不强，而且在扩展该类时无法继承私有属性。鱼和熊掌不可兼得！\n\n### ECMAScript类属性提案\n\nTypeScript提供了一个给类属性和方法使用的private修饰符。然而，该修饰符只在编译时有用（包括在前面讨论的TypeScript类型和错误检测）。在代码被转移完成后，属性同样是公开的。\n\n事实上，我们不能像在其他编程语言中一样声明私有属性和方法。虽然有很多种方法都可以达到相同的效果，但无论是在语法还是性能层面，这些方法都有各自的优点和缺点。\n\n哪种方法更好呢？这取决于你在实际项目中如何使用本书展示的算法，也取决于你需要处理的数据量、需要构造的实例数量，以及其他约束条件。最终，还是取决于你的选择。\n\n在[ES2020 实验草案](https://github.com/tc39/proposal-class-fields) 中，增加了定义私有类字段的能力，写法是使用一个#作为前缀。\n\n```js\nclass ClassWithPrivateField {\n  #privateField\n}\n\nclass ClassWithPrivateMethod {\n  #privateMethod() {\n    return 'hello world'\n }\n}\n\nclass ClassWithPrivateStaticField {\n  static #PRIVATE_STATIC_FIELD\n}\n```\n\n"}}]);
//# sourceMappingURL=88.chunk.js.map